"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LinuxTargetHelper = exports.installPrefix = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = require("bluebird-lst");
}

var _builderUtil;

function _load_builderUtil() {
    return _builderUtil = require("builder-util");
}

var _fs;

function _load_fs() {
    return _fs = require("builder-util/out/fs");
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = require("fs-extra-p");
}

var _lazyVal;

function _load_lazyVal() {
    return _lazyVal = require("lazy-val");
}

var _path = _interopRequireWildcard(require("path"));

var _pathManager;

function _load_pathManager() {
    return _pathManager = require("../util/pathManager");
}

var _tools;

function _load_tools() {
    return _tools = require("./tools");
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

const installPrefix = exports.installPrefix = "/opt";
class LinuxTargetHelper {
    constructor(packager) {
        this.packager = packager;
        this.iconPromise = new (_lazyVal || _load_lazyVal()).Lazy(() => this.computeDesktopIcons());
        this.maxIconPath = null;
    }
    get icons() {
        return this.iconPromise.value;
    }
    // must be name without spaces and other special characters, but not product name used
    computeDesktopIcons() {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const packager = _this.packager;
            const customIconSetDir = packager.platformSpecificBuildOptions.icon;
            if (customIconSetDir != null) {
                let iconDir = _path.resolve(packager.info.buildResourcesDir, customIconSetDir);
                const stat = yield (0, (_fs || _load_fs()).statOrNull)(iconDir);
                if (stat == null || !stat.isDirectory()) {
                    iconDir = _path.resolve(packager.projectDir, customIconSetDir);
                }
                try {
                    return yield _this.iconsFromDir(iconDir);
                } catch (e) {
                    if (e.code === "ENOENT") {
                        throw new Error(`Icon set directory ${iconDir} doesn't exist`);
                    } else if (e.code === "ENOTDIR") {
                        throw new Error(`linux.icon must be set to an icon set directory, but ${iconDir} is not a directory. Please see https://electron.build/configuration/configuration#LinuxBuildOptions-icon`);
                    } else {
                        throw e;
                    }
                }
            }
            const resourceList = yield packager.resourceList;
            if (resourceList.includes("icons")) {
                return yield _this.iconsFromDir(_path.join(packager.info.buildResourcesDir, "icons"));
            } else {
                return yield _this.createFromIcns();
            }
        })();
    }
    iconsFromDir(iconDir) {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const mappings = [];
            let maxSize = 0;
            for (const file of yield (0, (_fsExtraP || _load_fsExtraP()).readdir)(iconDir)) {
                if (file.endsWith(".png") || file.endsWith(".PNG")) {
                    // If parseInt encounters a character that is not a numeral in the specified radix,
                    // it returns the integer value parsed up to that point
                    try {
                        const sizeString = file.match(/\d+/);
                        const size = sizeString == null ? 0 : parseInt(sizeString[0], 10);
                        if (size > 0) {
                            const iconPath = `${iconDir}/${file}`;
                            mappings.push({
                                file: iconPath,
                                size
                            });
                            if (size > maxSize) {
                                maxSize = size;
                                _this2.maxIconPath = iconPath;
                            }
                        }
                    } catch (e) {
                        console.error(e);
                    }
                }
            }
            if (mappings.length === 0) {
                throw new Error(`Icon set directory ${iconDir} doesn't contain icons`);
            }
            return mappings;
        })();
    }
    getIcns() {
        var _this3 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const build = _this3.packager.info.config;
            let iconPath = (build.mac || {}).icon || build.icon;
            if (iconPath != null && !iconPath.endsWith(".icns")) {
                iconPath += ".icns";
            }
            return iconPath == null ? yield _this3.packager.getDefaultIcon("icns") : _path.resolve(_this3.packager.projectDir, iconPath);
        })();
    }
    getDescription(options) {
        return options.description || this.packager.appInfo.description;
    }
    writeDesktopEntry(targetSpecificOptions, exec, destination, extra) {
        var _this4 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const data = yield _this4.computeDesktopEntry(targetSpecificOptions, exec, extra);
            const tempFile = destination || (yield _this4.packager.getTempFile(`${_this4.packager.appInfo.productFilename}.desktop`));
            yield (0, (_fsExtraP || _load_fsExtraP()).outputFile)(tempFile, data);
            return tempFile;
        })();
    }
    computeDesktopEntry(targetSpecificOptions, exec, extra) {
        var _this5 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            if (exec != null && exec.length === 0) {
                throw new Error("Specified exec is empty");
            }
            const appInfo = _this5.packager.appInfo;
            const productFilename = appInfo.productFilename;
            const desktopMeta = Object.assign({ Name: appInfo.productName, Comment: _this5.getDescription(targetSpecificOptions), Exec: exec == null ? `"${installPrefix}/${productFilename}/${_this5.packager.executableName}" %U` : exec, Terminal: "false", Type: "Application", Icon: _this5.packager.executableName }, extra, targetSpecificOptions.desktop);
            let category = targetSpecificOptions.category;
            if ((0, (_builderUtil || _load_builderUtil()).isEmptyOrSpaces)(category)) {
                const macCategory = (_this5.packager.config.mac || {}).category;
                if (macCategory != null) {
                    category = macToLinuxCategory[macCategory];
                }
                if (category == null) {
                    // https://github.com/develar/onshape-desktop-shell/issues/48
                    if (macCategory != null) {
                        (_builderUtil || _load_builderUtil()).log.warn({ macCategory }, "cannot map macOS category to Linux. If possible mapping is known for you, please file issue to add it.");
                    }
                    (_builderUtil || _load_builderUtil()).log.warn({
                        reason: "linux.category is not set and cannot map from macOS",
                        docs: "https://electron.build/configuration/configuration#LinuxBuildOptions-category"
                    }, "application Linux category is set to default \"Utility\"");
                    category = "Utility";
                }
            }
            desktopMeta.Categories = `${category}${category.endsWith(";") ? "" : ";"}`;
            let data = `[Desktop Entry]`;
            for (const name of Object.keys(desktopMeta)) {
                const value = desktopMeta[name];
                data += `\n${name}=${value}`;
            }
            data += "\n";
            return data;
        })();
    }
    createFromIcns() {
        var _this6 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const iconPath = yield _this6.getIcns();
            if (iconPath == null) {
                return yield _this6.iconsFromDir(_path.join((0, (_pathManager || _load_pathManager()).getTemplatePath)("linux"), "electron-icons"));
            }
            const rootTmpDir = yield _this6.packager.info.tempDirManager.rootTempDir;
            const result = JSON.parse((yield (0, (_builderUtil || _load_builderUtil()).exec)((yield (0, (_tools || _load_tools()).getAppBuilderTool)()), ["icns-to-png", "--input", iconPath], {
                env: Object.assign({}, process.env, {
                    // icns-to-png creates temp dir amd cannot delete it automatically since result files located in and it is our responsibility remove it after use,
                    // so, we just set TMPDIR to tempDirManager.rootTempDir and tempDirManager in any case will delete rootTempDir on exit
                    TMPDIR: rootTmpDir,
                    // todo remove when app-builder will be updated to 0.2.0
                    ELECTRON_BUILDER_TMP_DIR: rootTmpDir })
            })));
            _this6.maxIconPath = result.maxIconPath;
            return result.icons;
        })();
    }
}
exports.LinuxTargetHelper = LinuxTargetHelper;
const macToLinuxCategory = {
    "public.app-category.graphics-design": "Graphics",
    "public.app-category.developer-tools": "Development",
    "public.app-category.education": "Education",
    "public.app-category.games": "Game",
    "public.app-category.video": "Video;AudioVideo",
    "public.app-category.utilities": "Utility",
    "public.app-category.social-networking": "Chat",
    "public.app-category.finance": "Finance"
};
//# sourceMappingURL=LinuxTargetHelper.js.map